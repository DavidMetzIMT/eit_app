from enum import Enum
import logging
from time import sleep
from typing import Any, Union

from eit_app.sciospec.constants import (
    CMD_GET_DEVICE_INFOS,
    CMD_GET_ETHERNET_CONFIG,
    CMD_GET_MEAS_SETUP,
    CMD_GET_OUTPUT_CONFIG,
    CMD_SET_ETHERNET_CONFIG,
    CMD_SET_MEAS_SETUP,
    CMD_SET_OUTPUT_CONFIG,
    CMD_SOFT_RESET,
    CMD_START_STOP_MEAS,
    OP_BURST_COUNT,
    OP_CURRENT_STAMP,
    OP_DHCP,
    OP_EXC_AMPLITUDE,
    OP_EXC_FREQUENCIES,
    OP_EXC_PATTERN,
    OP_EXC_STAMP,
    OP_FRAME_RATE,
    OP_IP_ADRESS,
    OP_MAC_ADRESS,
    OP_NULL,
    OP_RESET_SETUP,
    OP_START_MEAS,
    OP_STOP_MEAS,
    OP_TIME_STAMP,
    SUCCESS,
    SciospecCmd,
    SciospecOption,
)
from eit_app.sciospec.communicator import SciospecCommunicator
from eit_app.sciospec.interface import SciospecSerialInterface
from eit_app.sciospec.measurement import (
    DataAddRxMeasStream,
    DataInit4Start,
    DataReInit4Pause,
)
from eit_app.sciospec.setup import SciospecSetup
from eit_app.video.capture import SetStatusWMeasStatus
from eit_app.com_channels import (
    AddToCaptureSignal,
    AddToDatasetSignal,
    AddToGuiSignal,
    DataCheckBurst,
    DataLoadLastDataset,
    DataLoadSetup,
    SignalReciever,
)
from eit_app.update_gui import (
    EvtDataNewFrameInfo,
    EvtDataNewFrameProgress,
    EvtDataSciospecDevConnected,
    EvtDataSciospecDevices,
    EvtDataSciospecDevMeasuringStatusChanged,
    EvtDataSciospecDevSetup,
    EvtPopMsgBox,
    MeasuringStatus,
)
from glob_utils.flags.status import AddStatus
from glob_utils.log.log import main_log
import glob_utils.dialog.Qt_dialogs
from serial import (  # get from http://pyserial.sourceforge.net/
    PortNotOpenError,
    SerialException,
)

logger = logging.getLogger(__name__)

NONE_DEVICE = "None Device"


################################################################################

################################################################################


class SciospecEITDevice(
    SignalReciever, AddStatus, AddToGuiSignal, AddToDatasetSignal, AddToCaptureSignal
):

    """Device Class should only provide simple function to use the device such:
    - get devices
    - connect
    - disconnect
    - start/pause/resume/stop meas
    - set/get setup
    - reset"""

    n_channel: int  # nb of Channel from the EIT device
    # all sciospec connected to local machine generated by self.get_devices
    sciospec_devices: dict
    # Actual name of the device
    device_name: str

    setup: SciospecSetup
    serial_interface: SciospecSerialInterface

    # The communicator is charged to send cmd to the interface, sort and
    # manage the comunitation (ack, etc). it dispatch the data recivied on
    # two different Signals new_rx_meas_stream/new_rx_setup_stream
    communicator: SciospecCommunicator

    def __init__(self, n_channel: int = 32):
        super().__init__()

        self.init_status(status_values=MeasuringStatus)
        self.init_reciever(
            data_callbacks={
                DataLoadSetup: self.load_setup_from_signal,
                DataCheckBurst: self.check_burst,
            }  # TODO
        )
        self.n_channel = n_channel
        self.sciospec_devices = {}
        self.device_name: str = NONE_DEVICE
        self.setup = SciospecSetup(self.n_channel)
        self.serial_interface = SciospecSerialInterface()
        self.communicator = SciospecCommunicator()

        # all the errors from the interface are catch and send through this
        # error signal, the error are then here handled. Some of then need
        # action on the device itself
        self.serial_interface.error.connect(self._handle_interface_error)
        # send the new to be processed by the communicator
        self.serial_interface.new_rx_frame.connect(self.communicator.add_rx_frame)
        # output signal of the communicator
        self.communicator.new_rx_meas_stream.connect(self.emit_new_rx_meas_stream)
        self.communicator.new_rx_setup_stream.connect(self.setup.set_data)
        # self.meas_status.changed.connect(self.emit_meas_status)

    ## =========================================================================
    ##
    ## =========================================================================

    # @abstractmethod - AddStatus
    def status_has_changed(self, status: Enum, was_status: Enum) -> None:
        self.to_gui.emit(EvtDataSciospecDevMeasuringStatusChanged(status))
        meas_status_dev = self.is_measuring or self.is_paused
        self.to_capture.emit(SetStatusWMeasStatus(meas_status_dev))

    @property
    def is_measuring(self) -> bool:
        return self.is_status(MeasuringStatus.MEASURING)

    @property
    def is_paused(self) -> bool:
        return self.is_status(MeasuringStatus.PAUSED)

    @property
    def is_idle(self) -> bool:
        return self.is_status(MeasuringStatus.NOT_MEASURING)

    ## =========================================================================
    ##  Methods to update gui
    ## =========================================================================

    def to_gui_emit_connect_status(self) -> None:

        self.to_gui.emit(
            EvtDataSciospecDevConnected(self.is_connected, self.connect_prompt)
        )

    ## =========================================================================
    ##  Methods for dataset
    ## =========================================================================
    def emit_new_rx_meas_stream(self, **kwargs):
        """send the new rx measuremenst stream to be added in the dataset"""
        self.to_dataset.emit(DataAddRxMeasStream(kwargs["rx_meas_stream"]))

    ## =========================================================================
    ##  methods for interface
    ## =========================================================================
    def _handle_interface_error(self, error, **kwargs):
        """Manage the error from the interface, """
        if isinstance(error, PortNotOpenError):
            logger.warning(f"None devices available\n{error.__str__()}")
            self.to_gui.emit(EvtPopMsgBox("None devices available", f"{error.__str__()}", 'warn'))
        elif isinstance(error, SerialException):
            logger.warning(f"Device not detected\n{error.__str__()}")
            self.to_gui.emit(EvtPopMsgBox("Device not detected", f"{error.__str__()}", 'warn'))
            self.disconnect_device()
            self.get_devices()

    @property
    def is_connected(self) -> bool:
        """Return if device is connected"""
        return self.serial_interface.is_connected.is_set()

    @property
    def connect_prompt(self) -> bool:
        """buils the connection prompt of the device"""
        return (
            f"{self.device_name} - CONNECTED" if self.is_connected else self.device_name
        )

    ## =========================================================================
    ##  Methods on Comunicator
    ## =========================================================================

    def send_cmd(self, cmd: SciospecCmd, op: SciospecOption) -> bool:
        """Send a command option to interface via the communicator"""
        data = self.setup.get_data(cmd, op)
        return self.communicator.send_cmd_frame(self.serial_interface, cmd, op, data)

    # def listen_activate(self, activate:bool=True):
    #     """"""

    def check_burst(self, data: DataCheckBurst, **kwargs) -> None:
        """Check if the number of Burst(measurements) is reached,
        in that case the measurement mode will be stopped on the device

        should be Triggered from meas_dataset"""

        if not self.is_measuring:
            return
        burst = self.setup.get_burst()
        if burst > 0 and data.nb_frame_measured == burst:
            self.stop_meas()

    def check_not_measuring(force_stop: bool = False):
        """Decorator: which check if the device is not measuring

        - if device is not measuring >> the function is run
        - if device is measuring:
            - the measurement can be stopped by setting force_stop to `True`. A
            info msgBox will be popped to inform the user and the
            function will be run
            - otherwise a info msgBox will be popped to ask the user to stop
            the measuremnet before using that function

        Args:
            force_stop (bool, optional): set to `True` to force the device to
            run the function after stoping the measurements. Defaults to `False`.
        """

        def _check_not_measuring(func):
            def wrap(self, *args, **kwargs) -> Union[Any, None]:

                # if args:
                #     logger.debug(f"check_not_measuring :{args=}")
                # elif kwargs:
                #     logger.debug(f"check_not_measuring :{kwargs=}")
                # else:
                #     logger.debug("check_not_measuring not args kwargs")

                msg = None
                run_func = False
                if not self.is_measuring:  # if not measuring >> run func
                    run_func = True
                elif force_stop:
                    self.stop_meas()
                    msg = "Measurements have been stopped"
                    run_func = True
                else:
                    msg = "Please stop measurements first"
                if msg:  # show msg only if msg is not empty/None
                    logger.info(f'"Measurements still running!, {msg}')
                    glob_utils.dialog.Qt_dialogs.infoMsgBox(
                        "Measurements still running!", msg
                    )
                return func(self, *args, **kwargs) if run_func else None

            return wrap

        return _check_not_measuring

    ## =========================================================================
    ##  Connection with device
    ## =========================================================================

    @check_not_measuring()
    def set_device_name(self, name: str = None, *args, **kwargs):
        """Connect a actual device"""
        if (port := self._get_sciospec_port(name)) is None:
            logger.info(f"Sciospec device: {name} - NOT DETECTED")
        self.device_name = name if port else NONE_DEVICE

    @check_not_measuring()
    def get_devices(self, *args, **kwargs) -> dict:
        """Lists the available Sciospec device is available
        - Device infos are ask and if an ack is get: it is a Sciospec device..."""
        ports = self.serial_interface.get_ports_available()
        self.sciospec_devices = {}
        for port in ports:
            device_name = self._check_is_sciospec_dev(port)
            if device_name is not None:
                self.sciospec_devices[device_name] = port
                self.device_name = device_name
        self.to_gui.emit(EvtDataSciospecDevices(self.sciospec_devices))
        logger.info(f"Sciospec devices available: {list(self.sciospec_devices)}")
        return self.sciospec_devices

    @check_not_measuring()
    def connect_device(self, *args, **kwargs) -> bool:
        """Connect a actual device"""
        if (port := self._get_sciospec_port(self.device_name)) is None:
            return False
        if success := self._connect_interface(port):
            self.get_device_infos()

        self.device_name = self.device_name if success else NONE_DEVICE
        self.to_gui_emit_connect_status()
        logger.info(f"Connecting device '{self.device_name}' - {SUCCESS[success]}")
        return success

    @check_not_measuring()
    def disconnect_device(self, *args, **kwargs) -> None:
        """Disconnect actual device"""
        if success := self._disconnect_interface():
            # Some reinitializsation of internal objects after disconnection
            self.setup.reinit()
            self.serial_interface.reinit()
            self.communicator.reinit()

        logger.info(f"Disconnecting device '{self.device_name}' - {SUCCESS[success]}")
        self.device_name = NONE_DEVICE if success else self.device_name
        self.to_gui_emit_connect_status()
        self.get_devices()  # update the list of Sciospec devices available ????

    ## -------------------------------------------------------------------------
    ##  Internal methods
    ## -------------------------------------------------------------------------

    def _connect_interface(self, port: str = None, baudrate: int = None) -> bool:
        """Connect interface to port"""
        return self.serial_interface.open(port, baudrate)

    def _disconnect_interface(self) -> bool:
        """Disconnect actual interface"""
        return self.serial_interface.close()

    def _check_is_sciospec_dev(self, port) -> Union[str, None]:
        """Return a device name if the device presents on the port is a
        sciospec device otherwise return `None`"""
        tmp_sn = self.setup.get_sn(in_bytes=True)
        device_name = None
        self._connect_interface(port)
        self._stop_meas()  # in case that the device is still measuring!
        self.get_device_infos()
        device_name = self.setup.build_sciospec_device_name(port)
        self._disconnect_interface()
        self.setup.set_sn(tmp_sn)
        return device_name

    def _get_sciospec_port(self, device_name: str) -> Union[str, None]:
        """Asset if a port is defined for device name, and returen it if yes"""
        if not self.sciospec_devices:
            logger.warning("No Sciospec devices - DETECTED")
            glob_utils.dialog.Qt_dialogs.warningMsgBox(
                "No Sciospec devices - DETECTED",
                "Please refresh the list of availables device first and retry!",
            )
            return None
        if device_name not in self.sciospec_devices:
            logger.error(f'Sciospec device "{device_name}" - NOT FOUND')
            glob_utils.dialog.Qt_dialogs.errorMsgBox(
                "Sciospec device - NOT FOUND ",
                f'Please reconnect your device "{device_name}"',
            )
            return None
        return self.sciospec_devices[device_name]

    ## =========================================================================
    ##  Measurements with device
    ## =========================================================================

    def start_paused_resume_meas(self, *args, **kwargs) -> bool:
        """Switcht Measuring mode to assure
        start, pause and resume functionality"""
        if self.is_status(MeasuringStatus.NOT_MEASURING):
            self.to_dataset.emit(DataInit4Start(self.setup))
            self._begin_meas()
        elif self.is_status(MeasuringStatus.MEASURING):
            self._pause_meas()
        elif self.is_status(MeasuringStatus.PAUSED):
            self._resume_meas()

    def stop_meas(self, *args, **kwargs) -> None:
        """Stop measurements"""
        if success := self._stop_meas():
            self.set_status(MeasuringStatus.NOT_MEASURING)
            self.to_gui.emit(EvtDataNewFrameProgress(0, 0))
            self.to_dataset.emit(DataLoadLastDataset())
        logger.info(f"Stop Measurements - {SUCCESS[success]}")

    ## -------------------------------------------------------------------------
    ##  Internal methods
    ## -------------------------------------------------------------------------

    @check_not_measuring()
    def _begin_meas(self) -> bool:  # sourcery skip: class-extract-method
        """Begin measurements"""
        if success := self._start_meas():
            self.set_status(MeasuringStatus.MEASURING)
            self.to_gui.emit(EvtDataNewFrameInfo(""))
        logger.info(f"Start Measurements - {SUCCESS[success]}")
        return success

    @check_not_measuring()
    def _resume_meas(self) -> bool:
        """Resume measurements"""
        if success := self._start_meas():
            self.set_status(MeasuringStatus.MEASURING)
        logger.info(f"Resume Measurements - {SUCCESS[success]}")
        return success

    def _pause_meas(self) -> None:
        """Pause measurements"""
        if success := self._stop_meas():
            self.set_status(MeasuringStatus.PAUSED)
            self.to_dataset.emit(DataReInit4Pause())
            self.to_gui.emit(EvtDataNewFrameProgress(None, 0))  # not update idx_frame
        logger.info(f"Pause Measurements - {SUCCESS[success]}")

    def _start_meas(self) -> bool:  # sourcery skip: class-extract-method
        """Start measuring

        Send cmd to device
        """
        success = self.send_cmd(CMD_START_STOP_MEAS, OP_START_MEAS)
        self.communicator.wait_not_busy()
        return success

    def _stop_meas(self) -> bool:
        """Stop measurements

        Send cmd to device
        """
        success = self.send_cmd(CMD_START_STOP_MEAS, OP_STOP_MEAS)
        self.communicator.wait_not_busy()
        return success

    ## =========================================================================
    ##  Setup device
    ## =========================================================================

    @check_not_measuring()
    def get_device_infos(self, *args, **kwargs) -> None:
        """Ask for the serial nummer of the Device"""
        self.send_cmd(CMD_GET_DEVICE_INFOS, OP_NULL)
        self.communicator.wait_not_busy()
        self.to_gui.emit(EvtDataSciospecDevSetup(self.setup))
        logger.debug(f"Get Info Device: {self.setup.device_infos.get_sn()}")

    @check_not_measuring()
    def set_setup(self, *args, **kwargs) -> None:
        """Send the setup to the device"""
        logger.info("Setting device setup - start...")
        self.send_cmd(CMD_SET_OUTPUT_CONFIG, OP_EXC_STAMP)
        self.send_cmd(CMD_SET_OUTPUT_CONFIG, OP_CURRENT_STAMP)
        self.send_cmd(CMD_SET_OUTPUT_CONFIG, OP_TIME_STAMP)
        self.send_cmd(CMD_SET_ETHERNET_CONFIG, OP_DHCP)
        self.send_cmd(CMD_SET_MEAS_SETUP, OP_RESET_SETUP)
        self.send_cmd(CMD_SET_MEAS_SETUP, OP_EXC_AMPLITUDE)
        self.send_cmd(CMD_SET_MEAS_SETUP, OP_BURST_COUNT)
        self.send_cmd(CMD_SET_MEAS_SETUP, OP_FRAME_RATE)
        self.send_cmd(CMD_SET_MEAS_SETUP, OP_EXC_FREQUENCIES)
        for idx in range(len(self.setup.get_exc_pattern())):
            self.setup.set_exc_pattern_idx(idx)
            self.send_cmd(CMD_SET_MEAS_SETUP, OP_EXC_PATTERN)
        self.communicator.wait_not_busy()
        self.get_setup()
        logger.info("Setting device setup - done")

    @check_not_measuring()
    def get_setup(self, *args, **kwargs) -> None:
        """Get the setup of the device"""
        logger.info("Getting device setup - start...")
        self.send_cmd(CMD_GET_MEAS_SETUP, OP_EXC_AMPLITUDE)
        self.send_cmd(CMD_GET_MEAS_SETUP, OP_BURST_COUNT)
        self.send_cmd(CMD_GET_MEAS_SETUP, OP_FRAME_RATE)
        self.send_cmd(CMD_GET_MEAS_SETUP, OP_EXC_FREQUENCIES)
        self.send_cmd(CMD_GET_MEAS_SETUP, OP_EXC_PATTERN)
        self.send_cmd(CMD_GET_OUTPUT_CONFIG, OP_EXC_STAMP)
        self.send_cmd(CMD_GET_OUTPUT_CONFIG, OP_CURRENT_STAMP)
        self.send_cmd(CMD_GET_OUTPUT_CONFIG, OP_TIME_STAMP)
        self.send_cmd(CMD_GET_ETHERNET_CONFIG, OP_IP_ADRESS)
        self.send_cmd(CMD_GET_ETHERNET_CONFIG, OP_MAC_ADRESS)
        self.send_cmd(CMD_GET_ETHERNET_CONFIG, OP_DHCP)
        self.communicator.wait_not_busy()
        self.to_gui.emit(EvtDataSciospecDevSetup(self.setup))
        logger.info("Getting device setup - done")

    @check_not_measuring()
    def software_reset(self, *args, **kwargs) -> None:
        """Sofware reset the device
        Notes: a restart is needed after this method
        """
        logger.info("Softreset of device - start...")
        self.send_cmd(CMD_SOFT_RESET, OP_NULL)
        self.communicator.wait_not_busy()
        sleep(10)
        logger.info("Softreset of device - done")
        glob_utils.dialog.Qt_dialogs.infoMsgBox("Device reset ", "Reset done")

    def save_setup(self, *args, **kwargs) -> None:
        """Save Setup

        to save a setup which in a directory:
        use kwargs dir="the/dir/path/to/save"
        """
        self.setup.save(**kwargs)

    def load_setup_from_signal(self, data: DataLoadSetup) -> None:
        self.load_setup(dir=data.dir)

    def load_setup(self, *args, **kwargs) -> None:
        """Load Setup

        to load a setup which is in a directory:
        use kwargs dir="the/dir/path/to/load"
        """
        self.setup.load(**kwargs)
        self.to_gui.emit(EvtDataSciospecDevSetup(self.setup))


if __name__ == "__main__":
    import sys

    from PyQt5.QtWidgets import QApplication

    # app = QApplication(sys.argv)
    print(SUCCESS[True])
    print(SUCCESS[False])

    def print_e(**kwargs):
        print(f"{kwargs=}")

    main_log()

    dev = SciospecEITDevice()
    dev.to_dataset.connect(print_e)
    print("*+++++++++++++++++++++++++++++++++++++")
    dev.get_devices()
    print("*+++++++++++++++++++++++++++++++++++++")
    dev.connect_device()
    print("*+++++++++++++++++++++++++++++++++++++")
    dev.get_setup()
    print("*+++++++++++++++++++++++++++++++++++++")
    dev.set_setup()
    print("*+++++++++++++++++++++++++++++++++++++")
    dev._begin_meas()
    print("*+++++++++++++++++++++++++++++++++++++")
    sleep(1)
    dev._pause_meas()
    print("*+++++++++++++++++++++++++++++++++++++")
    sleep(1)
    dev._resume_meas()
    print("*+++++++++++++++++++++++++++++++++++++")
    sleep(1)
    dev.stop_meas()
    print("*+++++++++++++++++++++++++++++++++++++")
    dev.disconnect_device()
    print("*+++++++++++++++++++++++++++++++++++++")
    dev.connect_device()
